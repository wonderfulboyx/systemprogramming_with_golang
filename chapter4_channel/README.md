# メモ

## チャネル
- golangのチャネルはCSP(Communicating Sequential Processes)というTony Hoareが提唱したモデルをもとに実装されている
- プロセス同士が同じデータを触るのではなく、コミュニケーションしながら協調するモデル
    - 難しい並行処理プログラミングをかんたんにしつつ、壊れにくいコードを書きたいというモチベーション
- チャネルには以下のような特徴がある
    1. データを貯めるキューである
        - ランダムアクセスできない。必ずFIFO。
    2. 並列処理されても正しくデータを受け渡す同期機構である
        - 同時に複数のチャネルに読み書きを行っても、1つのgoroutineだけが書き込みを行える。
        - 同時に複数のチャネルに読み書きを行っても、1つのgoroutineだけが読み込みを行える。
        - この特徴を利用して、goroutine間のコミュニケーションにはチャネルを使うことが推奨されている。
    3. 読み書きの準備ができるまでブロックする機能である
        - チャネルにデータがない状態で読み込みをしようとすると、データが投入されるまでブロックされる。
        - チャネルのバッファに空きがない状態で書き込みしようとすると、チャネルからデータが取り出されてバッファに空きが出るまでブロックされる。
        - この性質を利用して待ち合わせや通知に利用される
- 低レベルプログラミングの文脈では、上記の特徴の3番目を利用して、OSからの通知を受けとるためにチャネルが使われる。
- チャネルを閉じるには`close(チャネル)`を使う。
- チャネル並列処理の終了を通知するためにもよく使われる
    ```go
  done := make(chan bool)
  go func() {
      // some processing
      done <- true
  } ()
  <- done // 終了までブロックする
    ```
    - 注意点は、チャネルがクローズされているか受信側が確実に知る明確な方法がないこと 
        - 多値を返却したり、クローズされていたときに返るデフォルト値をもってクローズを通知すべきではない。呼び出し側と実装側で合意がないと成り立たない。
        - **終了情報のためのチャネルを使うことが望ましい。**
    - データを流すチャネルは意図せぬデフォルト値を紛れ込ませてしまうことを防ぐためにcloseしないほうがよい。
    - **終了チャネルは呼び出し側に一斉通知できるためcloseしたほうがよい。**
- ブロックを避けるには`select`を使う。

       
